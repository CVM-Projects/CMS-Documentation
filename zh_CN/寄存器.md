# 寄存器

## 种类

CMS 是基于寄存器的，且寄存器数目在理论上是无限多的。

CMS 寄存器有如下几种：

- 通用寄存器： %t + 数字，数字为 从 1 开始的整数。每个线程间是相互独立的。
- 全局寄存器： %g + 数字，数字为 从 1 开始的整数。跨线程的共有寄存器。
- 私有寄存器： % + 数字，数字为 从 1 开始的整数。函数等进程私有的寄存器。
- 结果寄存器： %res ， 存储函数调用的结果的寄存器，实际上是调用函数指令中所指明的目标寄存器。
- 参数寄存器： %a + 数字，数字为 从 1 开始的整数。 参数寄存器在指令fcal中使用，实际上是将被调用函数的私有寄存器。

示例：

```
mov %1, %2
```

就是将 2 号 寄存器里的数据送入 1 号 寄存器中。

在寄存器标识符后加 'd' 或 's'，表示寄存器的动态或静态性。这在混合模式的环境中作为区分使用。（混合模式有两组寄存器，必须明确所使用的寄存器的模式。）

有时，不希望储存结果时，通过使用 %0 来表示舍弃运算的结果。

出于多线程的考虑，每个线程下都有名称相同的通用寄存器组，在不同线程下，调用不同的通用寄存器组。因此不会由通用寄存器冲突引发线程问题。

## 数据

寄存器通常存储函数调用的结果，或者代码中硬性赋入的初值。

一个动态变量在存储数据时，包含类型信息和数据的地址。

如
```
(let a 5i32)

; a 的结构表示（理论意义，不同实现有所不同）：
{
  type : Int32,
  data : int32_t* -> 5
}
```

而静态变量的存储则为：

```
data : 5
; or
data : int32_t* -> 5
```

因涉及到实现的便利性问题，通常将寄存器开辟为动态变量所需空间的大小，作为静态变量使用时，直接从最初的位置开始的整个空间作为存储数据的空间。

因此，为避免出现寄存器引用的混乱，编译器应该具有 **自动区分引用了动态变量数据的寄存器和引用（或存储）了静态变量数据的寄存器** 的能力。
