# 环境

环境 (Environment) 是 CMS 的核心之一。

按 处理内容 (Processing Content) 区分，环境可分为 作为所有环境根源的 全局环境 (Global Environment)、处理线程内容的 线程环境 (Thread Environment)、处理函数运行的 函数环境 (Function Environment) 等。

按 运行模式 (Runtime Mode) 区分，环境可分为 静态环境 (Static Environment)、动态环境 (Dynamic Environment)、混合环境 (Multiply Environment) 等。

按 处理范围 (Scope) 区分，环境可分为 全局环境 (Global Environment)、局部环境 (Local Environment)。其中，线程环境 (Thread Environment) 是一种特殊的局部环境。

## 组成

一个环境包含了以下几个内容：

- 环境信息 (Infomation)
    - 模式 (Mode)
    - 子环境 (Sub Environment)
    - 父环境 (Super Environment)
- 寄存器组 (Register Set)
- 数据 (Data)
- 程序 (Program)

一些特殊类型的环境还会包含其他的内容。

### 寄存器组

寄存器组 (Register Set) 是一组寄存器的通称。寄存器组是组成环境的重要一员。

按照运行模式来分，寄存器组有 静态 和 动态 两种。

按照寄存器组的长度，寄存器组有 固定长度 和 可变长度 两种。

局部环境的寄存器组是根据该环境的模式改变的。环境为静态时，只有静态寄存器组；环境为动态时，只有动态寄存器组；环境为混合态时，静态与动态寄存器组均存在。

## 环境的创建与销毁

所有环境销毁前，均需先销毁其子环境。

### 程序开始

程序开始，会创建一个全局环境。
全局环境的数据与全局声明有关。
全局环境会创建一个局部环境，这个局部环境就是程序运行的起点。

程序结束前，会销毁全局环境。
在销毁全局环境前，会将所有的局部环境销毁。

### 创建线程

全局环境在最初时，会创建一个主线程的线程环境。
当创建新线程时，会创建新的线程环境。

线程结束后，会销毁该线程的线程环境。

### 调用函数

当调用一个 CMS 的函数时，就会创建一个局部环境。
这个环境的模式与函数的模式和调用的模式有关。
函数声明中，会指定寄存器的数目和类型。这就是环境中寄存器组创建的依据。

调用函数结束后，会销毁该函数局部环境。

### 复制环境

使用指令可以复制当前的环境。这时会创建一个当前环境的副本。

## 数据

所有在环境内引用的数据，都被该环境所管理。在销毁该环境时，一并销毁数据。

当跨环境引用了数据时，数据归属于级别更高的环境（如该环境的父环境）。

## 程序

程序表示该环境内所引用的执行代码和执行状态。

当进入新的环境时，原环境的状态被保留；回到原环境时，可以恢复状态。

## 引用

环境是可以作为数据传递的。

一些闭包函数中要求传递环境作为参数，此时可以将环境传递。

## 环境相关指令

环境在指令中以环境指针的形式存在。

环境指针可以保存在静态寄存器中，也可以保存在动态寄存器中。环境类型是 CMS 的内置类型。

%env 当前环境寄存器。保存当前环境的指针。线程内通用，全局有多个。该寄存器在指令中只能读取。

%tenv 临时环境寄存器。该寄存器只能通过特殊的指令来写入和读取。

%penv 表示当前环境的父环境。该寄存器在指令中只能读取。

因为以上寄存器的操作都是通过特殊指令进行的，所以在具体的 CMS 实现中可以不设置寄存器的实体。

内容详见指令集内容。

## 绑定

在闭包中，函数与环境绑定。这在 CMS 中是一个默认支持的功能。

[?] 为区分绑定的环境与函数原生的环境，同时为了编译的方便性考虑，绑定的环境作为该函数的父环境。

有一段 Scheme 代码：

```scheme
(define (f n)
        (lambda (i) (+ n i)))

(let ((fv (f 5)))
     (display (fv 4)))
```

如上是一个闭包的典型用例，会被编译为：

``` 
.mode dynamic

.code

;; (define (f n)
;;         (lambda (i) (+ n i)))

f@lambda:
        .varb 1
        call %res, +, %1(%penv) %1
        ret
        
f:
        .varb 2

        ;; f@lambda + %env -> %tfun
        fbec f@lambda
        
        ;; scheme#procedure : function type in scheme.
        ;; scheme#_fpack : a custom function, cms#function -> scheme#procedure.
        call %res, scheme#_fpack, %tfun

        ret

;; (let ((fv (f 5)))
;;      (display (fv 4)))
        
main:
        call %1, f, 5
        call %1, %1, 4
        call %0, display, %1
        ret
```
